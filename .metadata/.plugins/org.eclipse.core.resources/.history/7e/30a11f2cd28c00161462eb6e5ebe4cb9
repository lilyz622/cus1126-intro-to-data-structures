
public class MergeVSInsertionSort {

	public static void main(String[] args) {
		int[][] testArray = createVariousArrays(1, 10, 100000);
		for (int array = 0; array < testArray.length; array++) {
			System.out.println("Array size:" + testArray[array].length + "MergeSort:" + mergeSortHelp(testArray[array])
					+ "\tInsertionSort:" + insertionSortHelp(testArray[array]));
		}
	}

	public static int[][] createVariousArrays(int smallest, int increment, int max) {
		int currentSize = smallest;
		int limit = max / increment;
		int[][] output = new int[limit][];
		int count = 0;
		while (currentSize <= max) {
			output[count] = createRandomArray(currentSize);
			currentSize += increment;
			count++;
		}
		return output;
	}

	/**
	 * Creates an array of random integers of size length
	 * 
	 * @param length
	 *            size of array
	 * @return random array of int
	 */
	public static int[] createRandomArray(int length) {
		int[] output = new int[length];
		for (int i = 0; i < output.length; i++) {
			output[i] = (int) Math.random() * RANDOM_RANGE;
		}
		return output;
	}

	/*
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 */
	public static long mergeSortHelp(int[] input) {
		long startTime = System.nanoTime();
		mergeSort(input, 0, input.length - 1);
		long estimatedTime = System.nanoTime() - startTime;
		// records.get((int) Math.log10(input.length)).add(estimatedTime);
		// System.out.println("The estimated time for array of length
		// 10^"+Math.log10(ar.length)+" is:"+estimatedTime);
		return estimatedTime;
	}

	public static void mergeSort(int a[], int low, int high) {
		if (low == high)
			return;
		int length = high - low + 1;
		int pivot = (low + high) / 2;
		mergeSort(a, low, pivot);
		mergeSort(a, pivot + 1, high);
		int working[] = new int[length];
		for (int i = 0; i < length; i++)
			working[i] = a[low + i];
		int m1 = 0;
		int m2 = pivot - low + 1;
		for (int i = 0; i < length; i++) {
			if (m2 <= high - low)
				if (m1 <= pivot - low)
					if (working[m1] > working[m2])
						a[i + low] = working[m2++];
					else
						a[i + low] = working[m1++];
				else
					a[i + low] = working[m2++];
			else
				a[i + low] = working[m1++];
		}
	}

	/*
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 */

	/**
	 * insertionSort algorithm sorts and times the sorting, and adds this
	 * information to the records
	 * 
	 * @param ar
	 *            integers
	 */

	public static long insertionSortHelp(int[] input) {
		long startTime = System.nanoTime();
		insertionSort(input);
		long estimatedTime = System.nanoTime() - startTime;

		// System.out.println("The estimated time for array of length
		// 10^"+Math.log10(ar.length)+" is:"+estimatedTime);
		return estimatedTime;

	}

	public static void insertionSort(int ar[]) {

		for (int i = 1; i < ar.length; i++) {
			int index = ar[i];
			int j = i;
			while (j > 0 && ar[j - 1] > index) {
				ar[j] = ar[j - 1];
				j--;
			}
			ar[j] = index;
		}

	}

}
